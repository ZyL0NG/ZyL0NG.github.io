<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="面试题, 華西の空間へようこそ">
    <meta name="description" content="Java 基础
基本数据类型





字节
默认值




byte
1
0



short
2
0



int
4
0



long
8
0L



float
4
0f



double
8
0d



char
2
‘u00">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>面试题 | 華西の空間へようこそ</title>
    <link rel="icon" type="image/png" href="/favicon.png">
    


    <!-- bg-cover style     -->



<link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
<link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
<link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
<link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
<link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
<link rel="stylesheet" type="text/css" href="/css/matery.css">
<link rel="stylesheet" type="text/css" href="/css/my.css">
<link rel="stylesheet" type="text/css" href="/css/dark.css" media="none" onload="if(media!='all')media='all'">




    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
    <link rel="stylesheet" href="/css/post.css">




    



    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="華西の空間へようこそ" type="application/atom+xml">

<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">華西の空間へようこそ</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
  <li>
    <a href="javascript:;" class="waves-effect waves-light" onclick="switchNightMode()" title="深色/浅色模式" >
      <i id="sum-moon-icon" class="fas fa-sun" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">華西の空間へようこそ</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/5.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">面试题</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/Java/">
                                <span class="chip bg-color">Java</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2023-04-14
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2023-05-16
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    19.1k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    67 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.min.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="Java-基础"><a href="#Java-基础" class="headerlink" title="Java 基础"></a>Java 基础</h1><ol>
<li><strong>基本数据类型</strong></li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th>字节</th>
<th>默认值</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>1</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>short</td>
<td>2</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>int</td>
<td>4</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>long</td>
<td>8</td>
<td>0L</td>
<td></td>
</tr>
<tr>
<td>float</td>
<td>4</td>
<td>0f</td>
<td></td>
</tr>
<tr>
<td>double</td>
<td>8</td>
<td>0d</td>
<td></td>
</tr>
<tr>
<td>char</td>
<td>2</td>
<td>‘u0000’</td>
<td></td>
</tr>
<tr>
<td>boolean</td>
<td>1比特</td>
<td>false</td>
<td></td>
</tr>
</tbody></table>
<ol start="2">
<li><strong>常量池技术</strong></li>
</ol>
<p>Java的包装类型（例如Integer、Boolean、Character等）都有一个内部的常量池，可以用来存储一些常用的包装类型对象，以便在程序中重用这些对象。这个技术被称为“包装类型常量池技术”。</p>
<p>当我们使用自动装箱的语法创建一个包装类型对象时，Java会首先检查该对象的值是否已经存在于常量池中。如果已经存在，Java会直接返回该对象的引用，而不是创建一个新的对象。这样可以节省内存，提高程序的性能。</p>
<ol start="3">
<li><strong>为什么有包装技术</strong></li>
</ol>
<p>基本数据类型有默认值，支持泛型和集合</p>
<ol start="4">
<li><strong>自动拆装箱</strong></li>
</ol>
<p>自动装箱是指Java编译器自动将基本数据类型转换为对应的包装类型，自动拆箱是指Java编译器自动将包装类型转换为对应的基本数据类型。在自动装箱时，Java编译器会自动将基本数据类型转换为对应的包装类型，实际上相当于调用了包装类型的valueOf()方法。在自动拆箱时，Java编译器会自动将包装类型转换为对应的基本数据类型，实际上相当于调用了包装类型的xxxValue()方法。</p>
<ol start="5">
<li><strong>NPE问题</strong></li>
</ol>
<p>数据库调用、三目运算符</p>
<p><code>String str = someCondition ? null : &quot;Hello&quot;; int length = str.length();</code></p>
<ol start="6">
<li><strong>string stringbuffer stringbuilder区别</strong></li>
</ol>
<table>
<thead>
<tr>
<th align="center"></th>
<th>长度</th>
<th></th>
<th>性能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">string</td>
<td>不可变</td>
<td>线程安全</td>
<td>最低</td>
</tr>
<tr>
<td align="center">stringbuffer</td>
<td>可变</td>
<td>线程安全synchronized</td>
<td>居中</td>
</tr>
<tr>
<td align="center">stringbuilder</td>
<td>可变</td>
<td>不安全</td>
<td>最高</td>
</tr>
</tbody></table>
<ol start="5">
<li><strong>重写和重载</strong></li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th>参数，返回列表</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>重写</td>
<td>子类重写父类方法</td>
<td>相同</td>
<td>运行</td>
<td>动态绑定</td>
</tr>
<tr>
<td>重载</td>
<td>一个类中多个方法</td>
<td>不同</td>
<td>编译</td>
<td>前期绑定</td>
</tr>
</tbody></table>
<ol start="7">
<li><strong>&#x3D;&#x3D;和equal的区别</strong></li>
</ol>
<p>&#x3D;&#x3D;用于比较两个对象的引用是否相等，equals()用于比较两个对象的内容是否相等。equals要重写否则和&#x3D;&#x3D;一样</p>
<ol start="8">
<li><table>
<thead>
<tr>
<th></th>
<th>是否可以访问外部类成员变量和方法</th>
<th>是否可以被外部访问</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>成员内部类</td>
<td>可以访问</td>
<td>可以访问</td>
<td></td>
<td></td>
</tr>
<tr>
<td>局部内部类</td>
<td>可以访问</td>
<td>不能</td>
<td></td>
<td></td>
</tr>
<tr>
<td>匿名内部类</td>
<td>可以访问</td>
<td>不能</td>
<td></td>
<td></td>
</tr>
<tr>
<td>静态内部类</td>
<td>可以访问外部静态成员</td>
<td>不能</td>
<td></td>
<td></td>
</tr>
</tbody></table>
</li>
<li><p><strong>接口和抽象类</strong></p>
</li>
</ol>
<p>抽象类是一种特殊的类，它不能被实例化，而是用来被继承的，通过使用关键字<code>abstract</code>来修饰。抽象类可以包含抽象方法和非抽象方法，抽象方法必须被子类实现，而非抽象方法可以被子类继承或者覆盖。而接口是一种特殊的类，它只包含方法的定义，没有方法的实现，通过使用关键字<code>interface</code>来修饰。实现接口的类必须实现接口中定义的所有方法。</p>
<p>一个类只能继承一个抽象类，但是一个类可以实现多个接口。</p>
<p>抽象类中可以包含构造方法，而接口中不能包含构造方法。</p>
<p>抽象类可以包含非抽象方法，这些方法可以被子类继承或者覆盖。而接口中只能包含抽象方法，这些方法必须被实现。</p>
<p>抽象类可以有成员变量，而接口中只能包含常量。</p>
<ol start="10">
<li>深拷贝和浅拷贝</li>
</ol>
<p>浅拷贝只是复制了对象的引用，而没有复制对象本身。深拷贝会递归复制一个对象及其所有的成员变量，确保新的对象与原对象没有任何关联。</p>
<p>深拷贝实现方法：重写对象的 clone() 方法。使用序列化和反序列化实现深拷贝。使用第三方库进行深拷贝。</p>
<h3 id="注解-反射"><a href="#注解-反射" class="headerlink" title="注解 反射"></a>注解 反射</h3><ol>
<li><strong>反射</strong></li>
</ol>
<p>应用场景：动态加载类和创建对象、动态获取和操作类的成员、动态扩展应用程序、动态代理</p>
<ol start="2">
<li><strong>注解</strong></li>
</ol>
<ul>
<li>加载类：注解是定义在Java类中的，因此在解析注解之前需要先加载包含注解的类。</li>
<li>解析注解：Java在运行时通过反射机制获取类的注解，解析注解的过程实际上是解析注解类型中的元数据。</li>
<li>获取元数据：元数据包括注解中定义的各种属性，包括默认值、数据类型、是否可重复等。Java通过反射机制获取注解中的元数据，并根据元数据对注解进行解析。</li>
<li>执行注解：Java会根据注解中的元数据执行相应的操作。例如，如果注解中定义了某个属性为A，那么Java会根据属性A的值执行相应的操作。</li>
</ul>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><ol>
<li><strong>泛型</strong></li>
</ol>
<p>使用泛型的好处在于可以在编译期间检查类型的一致性和安全性，避免在运行时出现类型转换错误和异常，提高代码的可读性和可维护性。同时，泛型还可以使代码更加通用和灵活，能够适应各种类型的数据和对象。</p>
<ol start="2">
<li><strong>作用</strong></li>
</ol>
<p>类型安全性：泛型可以让程序员在编写代码时指定某些变量或方法的类型，从而在编译时进行类型检查。</p>
<p>可读性：泛型可以使代码更加易读和易理解。</p>
<p>代码复用：泛型可以使代码更加灵活，使得代码可以适用于不同类型的数据，而无需为每种类型编写重复的代码。</p>
<p>集合类型的安全性：Java 集合类是泛型类型，泛型可以使集合类更加安全。</p>
<ol start="3">
<li><strong>泛型擦除机制</strong></li>
</ol>
<p>Java 泛型擦除机制（Generics Type Erasure）是指在编译时期将泛型类型信息擦除（erased）掉，转换为普通的非泛型类型，并且在运行时期不再有泛型类型信息存在。</p>
<ol start="4">
<li><strong>通配符</strong></li>
</ol>
<p>在 Java 泛型中，通配符（Wildcard）是一种用于表示泛型类型中未知类型参数的占位符。通配符用问号 <code>?</code> 表示，它可以出现在泛型类型、方法的参数列表、方法的返回值等地方。通配符可以使代码更加灵活，使得泛型类型可以适用于不同类型的数据。</p>
<p>无界通配符：无界通配符使用 <code>?</code> 表示，它表示类型参数可以是任何类型，包括 Object。</p>
<p>上界通配符：上界通配符使用 <code>extends</code> 关键字定义，它表示类型参数必须是指定类型的子类或本身。</p>
<p>上边界通配符：上边界通配符使用 <code>extends</code> 关键字定义，它表示类型参数必须是指定类型的子类或本身。</p>
<p>下边界通配符：下边界通配符使用 <code>super</code> 关键字定义，它表示类型参数必须是指定类型的超类或本身。</p>
<h3 id="string类"><a href="#string类" class="headerlink" title="string类"></a>string类</h3><h3 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h3><ol>
<li><strong>字符流和字节流</strong></li>
</ol>
<p>字节流操作的是字节（byte）数据，可以处理所有类型的数据，包括文本、图像、音频等二进制数据。字节流主要用于读写二进制文件（如图像、音频文件）和网络编程中传输二进制数据。</p>
<p>字符流操作的是字符（char）数据，可以自动处理字符编码与解码，支持多种编码格式（如UTF-8、GBK等），适合读写文本文件和处理文本数据。字符流主要用于读写文本文件，如txt、csv、xml等。</p>
<p>在处理字符数据时，如果直接使用字节流，需要自行实现字符编码和解码的过程，这会增加代码的复杂度和出错的可能性。而使用字符流，Java会自动完成字符编码和解码的工作，方便快捷。另外，字符流还提供了缓冲区和字符集转换等功能，可以提高数据的读写效率和灵活性。</p>
<ol start="2">
<li><strong>IO设计模式</strong></li>
</ol>
<p> 装饰器模式：InputStream、OutputStream、Reader和Writer等流类都是基于装饰器模式实现的。使用装饰器模式可以方便地扩展I&#x2F;O流的功能，同时也避免了类爆炸问题。</p>
<p>工厂模式：File类和FileInputStream&#x2F;FileOutputStream类等都使用了工厂模式。工厂模式可以封装对象的创建过程，隐藏创建的具体实现细节，提供简单的接口给客户端使用。</p>
<p>观察者模式：输入流或输出流发生某些事件（如数据可用或到达流的末尾）时，可以使用观察者模式通知相应的观察者对象进行处理。</p>
<p>适配器模式：InputStreamReader和OutputStreamWriter等转换流就是使用适配器模式实现的。适配器模式可以将一个类的接口转换成客户端需要的另一种接口。</p>
<ol start="3">
<li>体系</li>
</ol>
<p>字节流：输入都是 ×××InputStream</p>
<p>​				输出都是 ×××OutPutStream</p>
<p>字符流：输入都是 ×××Reader</p>
<p>​				输出都是 ×××Writer</p>
<h1 id="Java-集合"><a href="#Java-集合" class="headerlink" title="Java 集合"></a>Java 集合</h1><ol start="0">
<li><strong>list set map</strong></li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>List</td>
<td>有序</td>
<td>可以重复</td>
<td>ArrayList、LinkedList、Vector</td>
<td>Collection接口</td>
</tr>
<tr>
<td>Set</td>
<td>无序</td>
<td>不能重复</td>
<td>HashSet、TreeSet</td>
<td>Collection接口</td>
</tr>
<tr>
<td>Map</td>
<td>键值对</td>
<td>键不能重复</td>
<td>HashMap、TreeMap、LinkedHashMap</td>
<td>Map</td>
</tr>
</tbody></table>
<p>线程安全：Vector、Stack、Hashtable、ConcurrentHashMap、ConcurrentLinkedQueue</p>
<p>线程不安全：ArrayList、LinkedList、HashSet、TreeSet、HashMap</p>
<ol>
<li><strong>分类</strong></li>
</ol>
<p><em><strong>list</strong></em></p>
<table>
<thead>
<tr>
<th></th>
<th>底层实现</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>ArrayList（推荐）</td>
<td>Object数组</td>
<td>线程不安全</td>
<td>数组插入删除复杂度、随机访问</td>
<td>预留空间</td>
</tr>
<tr>
<td>Vector</td>
<td>Object数组</td>
<td>线程安全</td>
<td>数组插入删除复杂度</td>
<td></td>
</tr>
<tr>
<td>LinkedList</td>
<td>双向列表</td>
<td>线程不安全</td>
<td>链表插入删除复杂度</td>
<td>每个元素占更大空间</td>
</tr>
</tbody></table>
<!--ArrayList扩容机制：开始默认设置为0，增加第一个元素变为10，之后超限则扩容为1.5倍-->

<p><em><strong>Queue</strong></em>和<em><strong>Deque</strong></em></p>
<table>
<thead>
<tr>
<th></th>
<th>底层实现</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>PriorityQueue</td>
<td>Object数组</td>
<td>默认最小堆</td>
<td></td>
<td></td>
</tr>
<tr>
<td>ArrayQueue</td>
<td>Object数组+双指针</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ArrayDeque</td>
<td>可变长数组+双指针</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><em><strong>Map</strong></em></p>
<table>
<thead>
<tr>
<th></th>
<th>底层实现</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>HashMap</td>
<td>数组+链表，超过阈值改用数组+红黑树</td>
<td>线程不安全</td>
<td>默认容量16，扩容变为2倍</td>
<td></td>
</tr>
<tr>
<td>LinkedHashMap</td>
<td>HashMap+红黑树</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Hashtable</td>
<td>数组+链表</td>
<td>线程安全</td>
<td>默认容量11，扩容变为2n+1</td>
<td></td>
</tr>
<tr>
<td>TreeMap</td>
<td>红黑树</td>
<td>默认按key升序排列</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><em><strong>Set</strong></em>（元素唯一、线程不安全）</p>
<table>
<thead>
<tr>
<th></th>
<th>底层实现</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>HashSet</td>
<td>HashMap</td>
<td></td>
<td>不安全</td>
<td></td>
</tr>
<tr>
<td>LinkedHashSet</td>
<td>LinkedHashMap</td>
<td>FIFO</td>
<td></td>
<td></td>
</tr>
<tr>
<td>LinkedHashMap</td>
<td>HashMap</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>TreeSet</td>
<td>红黑树</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<ol start="2">
<li><p><strong>ArrayList Vector的区别</strong></p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th>扩容</th>
</tr>
</thead>
<tbody><tr>
<td>ArrayList</td>
<td>线程不安全</td>
<td>没有同步机制</td>
<td>性能更高</td>
<td>1.5</td>
</tr>
<tr>
<td>Vector</td>
<td>线程安全</td>
<td>synchronized关键字来保证线程安全</td>
<td>同步造成开销</td>
<td>2</td>
</tr>
</tbody></table>
</li>
<li><p><strong>ArrayList LinkedList的区别</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>底层</th>
<th>访问</th>
<th>插入删除</th>
<th>空间</th>
</tr>
</thead>
<tbody><tr>
<td>ArrayList</td>
<td>数组</td>
<td>O(1)</td>
<td>O(n)</td>
<td></td>
</tr>
<tr>
<td>LinkedList</td>
<td>双向链表</td>
<td>O(n)</td>
<td>O(1)</td>
<td>记录相邻节点</td>
</tr>
</tbody></table>
</li>
<li><p><strong>Queue和Dueue</strong></p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th>实现类</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>Queue</td>
<td>collection</td>
<td>FIFO</td>
<td>LinkedList和PriorityQueue</td>
<td></td>
</tr>
<tr>
<td>Dueue</td>
<td>collection</td>
<td>两端删除添加</td>
<td>ArrayDeque和LinkedList</td>
<td></td>
</tr>
</tbody></table>
</li>
<li><p><strong>ArrayDeque和LinkedList</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>底层</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>ArrayDeque</td>
<td>循环数组</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>LinkedList</td>
<td>链表</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
</li>
<li><p><strong>ConcurrentHashMap线程安全实现方法</strong></p>
</li>
</ol>
<p>ConcurrentHashMap的线程安全是通过分段锁机制来实现的。它将整个HashMap分成了多个Segment（段），每个Segment都是一个独立的哈希表，各自管理其中的元素。每个Segment都有一个独立的锁，对于每个操作，只需要锁定对应的Segment，而不是整个HashMap，这样可以减小锁的粒度，提高并发性能。</p>
<p>在ConcurrentHashMap中，每个Segment都是由一个HashEntry数组和一个链表组成的。当需要添加元素时，首先根据元素的hash值计算出应该放入哪个Segment中，然后在该Segment对应的HashEntry数组中查找是否已经存在该元素的key，如果存在，则更新该元素的value，如果不存在，则将该元素插入到链表中。在插入元素的过程中，需要先获取该Segment的锁，然后再进行插入操作。在查询元素时，也需要获取对应Segment的锁。</p>
<ol start="8">
<li><p><strong>ConcurrentHashMap和Hashtable</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>性能</th>
<th>键值对为null</th>
<th>迭代器</th>
<th>初始容量</th>
</tr>
</thead>
<tbody><tr>
<td>ConcurrentHashMap</td>
<td>分段锁</td>
<td>允许为空</td>
<td>弱迭代器</td>
<td>可以设置</td>
</tr>
<tr>
<td>Hashtable</td>
<td>synchronized</td>
<td>不允许</td>
<td>强迭代器</td>
<td>固定</td>
</tr>
</tbody></table>
</li>
<li><p><strong>HashMap</strong></p>
</li>
</ol>
<p><strong>HashMap底层实现</strong>：</p>
<p>JDK1.8 之前 <code>HashMap</code> 底层是 <strong>数组和链表</strong> 结合在一起使用也就是 <strong>链表散列</strong>。HashMap 通过 key 的 <code>hashcode</code> 经过扰动函数处理过后得到 hash 值，然后通过 <code>(n - 1) &amp; hash</code> 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</p>
<p>JDK1.8之后超过阈值会转化为红黑树</p>
<p><strong>HahsMap迭代方式</strong>：</p>
<ol>
<li><p>迭代器（Iterator）方式遍历；</p>
</li>
<li><p>For Each 方式遍历；</p>
</li>
<li><p>Lambda 表达式遍历（JDK 1.8+）;</p>
</li>
<li><p>Streams API 遍历（JDK 1.8+）。</p>
</li>
<li><p><strong>HashSet查重复</strong></p>
</li>
</ol>
<p>当你把对象加入<code>HashSet</code>时，<code>HashSet</code> 会先计算对象的<code>hashcode</code>值来判断对象加入的位置，同时也会与其他加入的对象的 <code>hashcode</code> 值作比较，如果没有相符的 <code>hashcode</code>，<code>HashSet</code> 会假设对象没有重复出现。但是如果发现有相同 <code>hashcode</code> 值的对象，这时会调用<code>equals()</code>方法来检查 <code>hashcode</code> 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让加入操作成功。</p>
<h1 id="Java并发"><a href="#Java并发" class="headerlink" title="Java并发"></a>Java并发</h1><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><ol start="7">
<li>volatile关键字**</li>
</ol>
<p><code>volatile</code> 是 Java 中的一个关键字，用来修饰变量。在多线程并发编程中，<code>volatile</code> 关键字的作用是告诉 JVM：这个变量是不稳定的，每次读取它的值时都需要从内存中重新获取，而不能使用 CPU 缓存中的值，同时在写入变量值时，也要立即刷新到内存中，而不是在某个时刻之后才进行。</p>
<p>使用 <code>volatile</code> 可以保证多线程并发访问该变量时的可见性和有序性，即任何线程对该变量的修改，都能立即反映到其他线程中。但是，<code>volatile</code> 并不能保证操作的原子性，因此不能完全替代 <code>synchronized</code>。</p>
<p>另外，由于 <code>volatile</code> 强制变量从内存中读写，因此其性能会稍微慢一些。一般来说，只有在对变量的写入操作较少，而对读取操作较多的情况下，才适合使用 <code>volatile</code>。</p>
<ol start="11">
<li><strong>synchronized</strong></li>
</ol>
<p><code>synchronized</code> 是 Java 中的一个关键字，翻译成中文是同步的意思，主要解决的是多个线程之间访问资源的同步性，可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。</p>
<p>使用方法：</p>
<ul>
<li>修饰实例方法：给当前对象实例加锁，进入同步代码前要获得 <strong>当前对象实例的锁</strong> </li>
<li>修饰静态方法：给当前类加锁，会作用于类的所有对象实例 ，进入同步代码前要获得 <strong>当前 class 的锁</strong></li>
<li>修饰代码块： 表示进入同步代码库前要获得 <strong>给定对象的锁</strong>、表示进入同步代码前要获得 <strong>给定 Class 的锁</strong></li>
</ul>
<ol start="12">
<li>ReentranLock和synchronized的区别</li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th>ReentranLock</th>
<th>synchronized</th>
</tr>
</thead>
<tbody><tr>
<td>可重入锁</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>底层</td>
<td>API</td>
<td>JVM</td>
</tr>
<tr>
<td>功能</td>
<td>等待可中断、公平锁、条件变量</td>
<td></td>
</tr>
<tr>
<td>锁粒度</td>
<td>代码块</td>
<td>方法</td>
</tr>
<tr>
<td>性能</td>
<td>高并发场景更好</td>
<td>低并发场景更好</td>
</tr>
</tbody></table>
<h3 id="线程进程"><a href="#线程进程" class="headerlink" title="线程进程"></a>线程进程</h3><p><strong>进程</strong>：进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。</p>
<p><strong>线程</strong>：线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。</p>
<ol>
<li><strong>从JVM角度说明线程和进程</strong></li>
</ol>
<p>线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反。</p>
<ol start="2">
<li><strong>线程生命周期</strong></li>
</ol>
<p>NEW: 初始状态，线程被创建出来但没有被调用 <code>start()</code> 。</p>
<p>RUNNABLE: 运行状态，线程被调用了 <code>start()</code>等待运行的状态。</p>
<p>BLOCKED ：阻塞状态，需要等待锁释放。</p>
<p>WAITING：等待状态，表示该线程需要等待其他线程做出一些特定动作（通知或中断）。</p>
<p>TIME_WAITING：超时等待状态，可以在指定的时间后自行返回而不是像 WAITING 那样一直等待。</p>
<p>TERMINATED：终止状态，表示该线程已经运行完毕。</p>
<ol start="3">
<li><strong>线程上下文切换</strong></li>
</ol>
<p>线程切换条件：</p>
<ul>
<li><p>主动让出 CPU，比如调用了 <code>sleep()</code>, <code>wait()</code> 等。</p>
</li>
<li><p>时间片用完，因为操作系统要防止一个线程或者进程长时间占用 CPU 导致其他线程或者进程饿死。</p>
</li>
<li><p>调用了阻塞类型的系统中断，比如请求 IO，线程被阻塞。</p>
</li>
<li><p>被终止或结束运行</p>
</li>
</ul>
<p>这其中前三种都会发生线程切换，线程切换意味着需要保存当前线程的上下文，留待线程下次占用 CPU 的时候恢复现场。并加载下一个将要占用 CPU 的线程上下文。这就是所谓的 <strong>上下文切换</strong>。</p>
<ol start="4">
<li><strong>产生死锁的条件</strong></li>
</ol>
<p>互斥条件：该资源任意一个时刻只由一个线程占用。</p>
<p>请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。</p>
<p>不剥夺条件:线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</p>
<p>循环等待条件:若干线程之间形成一种头尾相接的循环等待资源关系。</p>
<ol start="5">
<li><p><strong>sleep()和wait()方法对比</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>sleep()</th>
<th>wait()</th>
</tr>
</thead>
<tbody><tr>
<td>锁</td>
<td>没释放</td>
<td>释放</td>
</tr>
<tr>
<td>使用场景</td>
<td>线程交互通信</td>
<td>暂停执行</td>
</tr>
<tr>
<td>是否自动苏醒</td>
<td>自动苏醒</td>
<td>notify()或notifyAll()方法来唤醒</td>
</tr>
<tr>
<td>来源</td>
<td>thread类本地方法</td>
<td>object类方法</td>
</tr>
</tbody></table>
</li>
</ol>
<!--wait设置在object是因为需要对象释放对象锁，sleep设置在thread是因为只是暂停不涉及对象-->

<ol start="6">
<li><strong>可以直接调用thread的run()吗？</strong></li>
</ol>
<p> 调用 <code>start()</code> 方法方可启动线程并使线程进入就绪状态，直接执行 <code>run()</code> 方法的话会把 <code>run()</code> 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p>
<ol start="8">
<li><strong>乐观锁和悲观锁</strong></li>
</ol>
<p><strong>悲观锁</strong>：悲观锁总是假设最坏的情况，认为共享资源每次被访问的时候就会出现问题(比如共享数据被修改)，所以每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放。也就是说，<strong>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程</strong>。悲观锁通常多用于写比较多的情况下（多写场景，竞争激烈），这样可以避免频繁失败和重试影响性能，悲观锁的开销是固定的。</p>
<p><strong>乐观锁</strong>：乐观锁总是假设最好的情况，认为共享资源每次被访问的时候不会出现问题，线程可以不停地执行，无需加锁也无需等待，只是在提交修改的时候去验证对应的资源（也就是数据）是否被其它线程修改了。乐观锁通常多于写比较少的情况下（多读场景，竞争较少），这样可以避免频繁加锁影响性能。不过，乐观锁主要针对的对象是单个共享变量。</p>
<ol start="9">
<li><strong>乐观锁实现方式</strong></li>
</ol>
<p>版本号机制：一般是在数据表中加上一个数据版本号 <code>version</code> 字段，表示数据被修改的次数。当数据被修改时，<code>version</code> 值会加一。当线程 A 要更新数据值时，在读取数据的同时也会读取 <code>version</code> 值，在提交更新时，若刚才读取到的 version 值为当前数据库中的 <code>version</code> 值相等时才更新，否则重试更新操作，直到更新成功。</p>
<p>CAS算法：涉及到三个操作数：<strong>V</strong> ：要更新的变量值(Var)   <strong>E</strong> ：预期值(Expected)   <strong>N</strong> ：拟写入的新值(New)。当且仅当 V 的值等于 E 时，CAS 通过原子方式用新值 N 来更新 V 的值。如果不等，说明已经有其它线程更新了 V，则当前线程放弃更新。</p>
<ol start="10">
<li><strong>乐观锁的问题</strong></li>
</ol>
<ul>
<li><p>ABA问题：如果一个变量 V 初次读取的时候是 A 值，并且在准备赋值的时候检查到它仍然是 A 值，可能在这段时间它的值可能被改为其他值，然后又改回 A，那 CAS 操作就会误认为它从来没有被修改过。这个问题被称为 CAS 操作的 <strong>“ABA”问题。</strong></p>
<p>ABA 问题的解决思路是在变量前面追加上<strong>版本号或者时间戳</strong>。</p>
</li>
<li><p>循环时间开销大：CAS 经常会用到自旋操作来进行重试，也就是不成功就一直循环执行直到成功。如果长时间不成功，会给 CPU 带来非常大的执行开销。</p>
<p>使用pause指令</p>
</li>
<li><p>只能保证一个共享变量的原子操作</p>
</li>
</ul>
<h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p><code>ThreadLocal</code> 是 Java 中的一个类，它提供了线程本地变量的支持。每个线程都拥有自己的 <code>ThreadLocal</code> 变量副本，线程之间的操作互不干扰。</p>
<p><code>ThreadLocal</code> 的作用是在多线程环境中，为每个线程提供一个独立的变量副本，这样每个线程都可以独立地改变自己的变量副本，而不会影响其他线程。这种方式通常被用来实现线程安全的对象，例如日期格式化器和数据库连接等。</p>
<p>具体来说，<code>ThreadLocal</code> 可以用来存储线程相关的数据，例如用户信息、Session、数据库连接等，这些数据在多线程环境下需要被共享，但是又不能被不同线程之间共享，否则会造成数据混乱。</p>
<p>另外，<code>ThreadLocal</code> 的实现原理是在每个线程内部维护一个 <code>ThreadLocalMap</code> 类型的映射表，用于存储变量副本。当调用 <code>ThreadLocal</code> 的 <code>get()</code> 方法时，会根据当前线程获取对应的变量副本；当调用 <code>set()</code> 方法时，会将变量副本存储到当前线程的映射表中；当不再需要该变量时，需要调用 <code>ThreadLocal</code> 的 <code>remove()</code> 方法来删除该变量副本，避免内存泄漏。</p>
<p>Thread类中包括<code>threadLocals</code> 和 一个 <code>inheritableThreadLocals</code> 变量，它们都是 <code>ThreadLocalMap</code> 类型的变量。<strong>最终的变量是放在了当前线程的 <code>ThreadLocalMap</code> 中，并不是存在 <code>ThreadLocal</code> 上，<code>ThreadLocal</code> 可以理解为只是<code>ThreadLocalMap</code>的封装，传递了变量值。</strong></p>
<p><strong>每个<code>Thread</code>中都具备一个<code>ThreadLocalMap</code>，而<code>ThreadLocalMap</code>可以存储以<code>ThreadLocal</code>为 key ，Object 对象为 value 的键值对。</strong></p>
<ol>
<li><strong>内存泄漏</strong></li>
</ol>
<p><code>ThreadLocalMap</code> 中使用的 key 为 <code>ThreadLocal</code> 的弱引用，而 value 是强引用。所以，如果 <code>ThreadLocal</code> 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。这样一来，<code>ThreadLocalMap</code> 中就会出现 key 为 null 的 Entry。假如我们不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。<code>ThreadLocalMap</code> 实现中已经考虑了这种情况，在调用 <code>set()</code>、<code>get()</code>、<code>remove()</code> 方法的时候，会清理掉 key 为 null 的记录。使用完 <code>ThreadLocal</code>方法后 最好手动调用<code>remove()</code>方法</p>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><ol>
<li><strong>优点</strong></li>
</ol>
<p>降低资源消耗、提高响应速度、提高线程可管理性</p>
<ol start="2">
<li><strong>创建方法</strong></li>
</ol>
<p>通过<code>ThreadPoolExecutor</code>构造函数来创建、通过 <code>Executor</code> 框架的工具类 <code>Executors</code> 来创建</p>
<ol start="3">
<li><strong>线程池参数</strong></li>
</ol>
<p><strong><code>corePoolSize</code> :</strong> 任务队列未达到队列容量时，最大可以同时运行的线程数量。</p>
<p><strong><code>maximumPoolSize</code> :</strong> 任务队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</p>
<p><strong><code>keepAliveTime</code></strong>:线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 <code>keepAliveTime</code>才会被回收销毁；</p>
<p>unit：时间单位；</p>
<p>workQueue：阻塞队列</p>
<p>threadFactory：线程工厂</p>
<p>handler：拒绝策略</p>
<ol start="4">
<li><strong>线程池常用阻塞队列</strong></li>
</ol>
<p>有界队列、</p>
<p>无界队列：队列容量无限大</p>
<p>同步队列：每次有新任务先判断有没有空闲线程，没有直接就创建一个线程</p>
<p>延迟阻塞队列：</p>
<ol start="5">
<li><strong>线程池处理任务流程</strong></li>
</ol>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%9B%BE%E8%A7%A3%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.png" alt="图解线程池实现原理"></p>
<ol start="6">
<li>拒绝策略</li>
</ol>
<ul>
<li><p><strong><code>ThreadPoolExecutor.AbortPolicy</code>：</strong> <strong>抛出异常</strong>来拒绝新任务的处理。</p>
</li>
<li><p><strong><code>ThreadPoolExecutor.CallerRunsPolicy</code>：</strong> 调用执行自己的线程运行任务，也就是直接在调用<code>execute</code>方法的线程中运行(<code>run</code>)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务</p>
</li>
<li><p><strong><code>ThreadPoolExecutor.DiscardOldestPolicy</code>：</strong> 此策略将<strong>丢弃最早的未处理的任务</strong>请求。</p>
</li>
<li><p><strong><code>ThreadPoolExecutor.DiscardPolicy</code>：</strong> 不处理新任务，<strong>直接丢弃</strong>掉。</p>
</li>
</ul>
<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><ol>
<li><strong>sql语句执行过程</strong></li>
</ol>
<p>语法解析——权限验证——查询缓存——查询优化器——执行计划生成——数据检索——数据排序分组——数据返回——事务处理</p>
<ol start="2">
<li><strong>存储引擎架构</strong></li>
</ol>
<p>MySQL的存储引擎架构是一个插件式的架构。</p>
<p>包括组件：</p>
<ol start="3">
<li><p><strong>MyISAM和InnoDB</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>事务</th>
<th>锁</th>
<th>数据缓存</th>
<th>外键约束</th>
<th>索引</th>
<th>崩溃恢复</th>
</tr>
</thead>
<tbody><tr>
<td>MyISAM</td>
<td>不支持</td>
<td>表级锁</td>
<td>键缓存</td>
<td>不支持</td>
<td>全文索引</td>
<td></td>
</tr>
<tr>
<td>InnoDB</td>
<td>支持</td>
<td>行级锁</td>
<td>缓冲池</td>
<td>支持</td>
<td>普通索引</td>
<td>自动崩溃恢复和恢复日志功能</td>
</tr>
</tbody></table>
</li>
<li><p><strong>char和varchar的区别</strong></p>
</li>
</ol>
<p><code>CHAR</code>和<code>VARCHAR</code>的区别在于，<code>CHAR</code>是固定长度的，如果存储的内容不足长度，则会补齐空格；<code>VARCHAR</code>是可变长度的，根据存储的内容动态分配空间，不会补齐空格。</p>
<p>varchar有两字节记录长度，扩容时如果空间还够直接添加，否则要开辟新空间然后复制删除。</p>
<ol start="5">
<li>建表考虑的问题</li>
</ol>
<p>数据库设计、数据类型、主键设计、索引设计、字段属性、数据库引擎、数据库安全、数据库备份与恢复</p>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><ol start="4">
<li><strong>事务</strong></li>
</ol>
<p>数据库事务（Transaction）是指一组数据库操作，这组操作被视为一个不可分割的工作单元，只有在所有操作都完成时，才会被提交到数据库中，否则会被回滚（Rollback）并撤销所有操作。</p>
<ol start="5">
<li><strong>事务特点</strong></li>
</ol>
<p>原子性、一致性、隔离性、持久性</p>
<ol start="6">
<li><strong>并发事务带来的问题</strong></li>
</ol>
<p>脏读（Dirty Read）：指一个事务读取了另一个事务未提交的数据。</p>
<p>不可重复读（Non-Repeatable Read）：指一个事务多次读取同一条记录，但在读取的过程中，这条记录被另一个事务修改了，导致读取的结果不一致。</p>
<p>幻读（Phantom Read）：指一个事务执行了一次范围查询，但在查询的过程中，另一个事务插入了一条新的数据，导致查询的结果不一致。</p>
<ol start="7">
<li><strong>不可重复读和幻读的区别</strong></li>
</ol>
<p>不可重复读是指在一个事务中，多次读取同一条记录，但在此期间另一个事务更新了该记录，导致两次读取的结果不一致。幻读是指在一个事务中，多次查询同一范围的记录，但在此期间另一个事务插入了一条符合查询条件的记录，导致两次查询的结果不一致。</p>
<p>不可重复读的原因是在一个事务中多次读取同一条记录时，另一个事务可能会更新该记录。幻读的原因是在一个事务中多次查询相同的条件时，另一个事务可能会插入一条符合查询条件的记录。</p>
<ol start="8">
<li><strong>事务隔离级别</strong></li>
</ol>
<p>读未提交、读已提交、可重复读（mysql默认级别）、串行化</p>
<ol start="9">
<li><strong>MVCC</strong></li>
</ol>
<p><strong>作用</strong>：MVCC采用版本号或时间戳来标识数据版本，每个事务在读取数据时只读取自己开始时间之前的数据版本，而对数据的修改会创建新的数据版本。这样，即使多个事务对同一数据进行读写操作，也不会相互阻塞。而且，当一个事务要修改某个数据行时，如果该数据行已被其他事务修改，则会进行冲突检测，从而避免数据的丢失或者不一致。</p>
<p><strong>原理</strong>：</p>
<ol>
<li><p>每个数据行都有版本号或时间戳</p>
</li>
<li><p>事务读取数据时，只会读自己开始之前可见的版本，如果该版本数据被修改就回滚事务，知道读到可见版本</p>
</li>
<li><p>事务修改数据时，创建新数据版本，与当前事务关联，如果已经被修改就需要冲突检测</p>
</li>
<li><p>某个数据版本被所有事务都看不见，则清理掉该版本</p>
</li>
<li><p>InnoDB 存储引擎的行锁</p>
</li>
</ol>
<p>记录锁（Record Lock）是 InnoDB 存储引擎最基本的锁类型，用于锁定某一行数据。</p>
<p>间隙锁（Gap Lock）用于锁定一个范围，而不是单独的某一行数据。</p>
<p>临建锁（Next-Key Lock）是记录锁和间隙锁的结合，既可以锁定某一行数据，也可以锁定一个范围。临建锁用于解决幻读问题，同时也可以避免覆盖读和不可重复读的产生。</p>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><ol start="0">
<li><strong>索引</strong></li>
</ol>
<p>索引是一种特殊的数据结构，用于在数据库中快速定位数据。</p>
<p>作用：索引可以加速数据的检索和查询，同时也可以提高数据库的性能和并发能力。</p>
<p>缺点：用额外的存储空间，并且在插入、修改和删除数据时会增加额外的操作开销。</p>
<ol>
<li><strong>索引分类</strong></li>
</ol>
<p>功能逻辑：普通索引、唯一索引、主键索引、全文索引</p>
<p>实现方式：聚簇索引、非聚簇索引</p>
<p>作用字段：单列索引、联合索引</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>普通索引</td>
<td>普通字段添加的索引，没有特殊要求</td>
<td></td>
</tr>
<tr>
<td>唯一索引</td>
<td>字段的值是唯一的，可以有多个唯一性索引</td>
<td>unique</td>
</tr>
<tr>
<td>主键索引</td>
<td>主键添加的索引，一张表只有一个</td>
<td></td>
</tr>
<tr>
<td>全文索引</td>
<td>用于处理文本数据。对文本进行分词，然后将分词结果存储在倒排索引中</td>
<td>fulltext</td>
</tr>
<tr>
<td>聚簇索引</td>
<td>将数据存储在索引中，每个表只能有一个聚簇索引</td>
<td></td>
</tr>
<tr>
<td>非聚簇索引</td>
<td>将索引和数据分开存储，索引中只包含索引列的值和指向数据行的指针。</td>
<td></td>
</tr>
<tr>
<td>单列索引</td>
<td>一个字段上的索引</td>
<td></td>
</tr>
<tr>
<td>联合索引</td>
<td>多个字段组合创建的索引</td>
<td></td>
</tr>
</tbody></table>
<ol start="2">
<li><strong>建立索引考虑问题</strong></li>
</ol>
<p>索引类型、索引列、索引长度、索引复合、索引选择性、索引覆盖、索引使用、索引删除、索引优化</p>
<ol start="3">
<li><strong>主键索引和二级索引</strong></li>
</ol>
<p>主键索引是一种特殊的索引类型，它是用于唯一标识每一行数据的索引。在 MySQL 中，每一张表都必须有一个主键索引。</p>
<p>二级索引则是指除了主键索引以外的其他索引，用于提高查询效率。二级索引的查找方式与主键索引类似，但是由于每一行数据都会有一个对应的主键值，因此二级索引需要先通过主键值找到行数据，再进行二次查找。<strong>先查二级索引再查主键索引</strong>。</p>
<p>区别：主键索引是唯一的，而二级索引可以重复。</p>
<p>​			主键索引是必须的，而二级索引是可选的。</p>
<p>​			主键索引的大小一定小于二级索引。</p>
<ol start="4">
<li><strong>覆盖索引</strong></li>
</ol>
<p>覆盖索引是指在查询语句中，所有需要返回的字段都可以从索引中获取，而不需要再到数据表中进行查询的一种情况。</p>
<p>使用覆盖索引的优点是可以减少查询语句的 IO 操作次数，从而提高查询效率。同时，由于不需要访问数据表，所以在查询过程中也不会发生锁的冲突，从而避免了死锁等问题的发生。</p>
<p>要求：</p>
<ol>
<li><p>查询语句中需要返回的所有字段都被包含在索引中。</p>
</li>
<li><p>索引必须是一个覆盖索引，即所有需要返回的字段的值都在索引中。</p>
</li>
<li><p><strong>联合索引</strong></p>
</li>
</ol>
<p>联合索引是指将多个字段组合成一个索引的方式。联合索引可以提高查询效率，因为可以用于查询多个条件。</p>
<ol start="6">
<li><strong>最左前缀匹配规则</strong></li>
</ol>
<p>最左前缀匹配规则是用于优化索引查询的一种技术。该规则指出，如果在一个复合索引（即包含多个列的索引）中，查询条件只涉及到索引的最左侧列或最左侧列的连续子集，则可以利用该索引进行快速匹配。</p>
<ol start="7">
<li><strong>索引失效</strong></li>
</ol>
<p>函数操作、使用了 NOT、!&#x3D;、&lt;&gt;、OR 操作符、索引列排序分组、模糊查询、数据类型不匹配、索引列过长、数据量小、统计信息不准确</p>
<h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><ol>
<li><strong>常见日志类型</strong></li>
</ol>
<p>错误日志（Error log）：记录MySQL服务器在启动、运行过程中出现的错误信息和警告信息；</p>
<p>查询日志（Query log）：记录MySQL服务器接收到的所有查询请求，可用于性能调优和问题排查；</p>
<p>慢查询日志（Slow query log）：记录执行时间超过指定阈值（默认为10秒）的SQL语句，可以帮助识别性能瓶颈和优化查询语句；</p>
<p>二进制日志（Binary log）：记录所有修改数据库数据的操作，可用于数据备份和恢复、数据同步等；</p>
<p>事务日志（Transaction log）：记录MySQL执行的所有事务操作，用于数据恢复和恢复到指定的时间点；</p>
<p>慢查询摘要日志（Slow query summary log）：记录慢查询的信息摘要，可用于分析查询性能和优化</p>
<ol start="2">
<li><strong>redo log实现事务可持久性</strong></li>
</ol>
<p>当执行一条事务中的SQL语句时，会首先将修改的数据记录到内存中的Redo log缓冲区中，然后再将修改同步到磁盘上的数据文件中。Redo log采用循环写入的方式，当缓冲区写满后，就会将缓冲区中的数据写入到磁盘上的Redo log文件中，然后再将缓冲区清空，以便接收下一个事务的修改。</p>
<p>当MySQL宕机或崩溃时，可以通过Redo log中记录的事务日志信息来进行数据恢复。在MySQL重新启动时，会首先读取Redo log文件中的内容，并将其中尚未同步到数据文件的修改重新应用到数据文件中，从而恢复数据的一致性。</p>
<ol start="3">
<li><strong>undo log实现事务的原子性</strong></li>
</ol>
<p>Undo log是记录了事务在修改数据时的原始值的一种日志，用于在回滚事务时恢复数据。当事务进行修改操作时，MySQL会将修改前的数据记录在Undo log中，然后将新数据写入到数据页中。如果事务需要回滚，MySQL会读取Undo log中的原始值，然后将其写入到对应的数据页中，从而撤销事务的修改操作。</p>
<p>需要注意的是，Undo log只记录了事务在修改数据时的原始值，并不记录事务执行过程中的所有操作。因此，在使用Undo log进行回滚时，可能会有一些操作无法回滚。此外，Undo log还需要占用一定的存储空间，因此需要定期进行清理。</p>
<ol start="4">
<li><strong>binlog</strong></li>
</ol>
<p>记录对数据库执行的更改操作，即使表结构变更和表数据修改没有使数据库修改，也会被记录。</p>
<p>分类：</p>
<p>​	statement模式：每一条修改数据的sql都会记录</p>
<p>​	row模式：每一行具体变更事件</p>
<p>​	mixed模式：statement和row的混合模式默认statement</p>
<p>主要应用场景：主从复制</p>
<p>刷盘时机：在 MySQL 中，事务提交时会将事务的所有更改写入 binlog 文件中，然后将其刷盘到磁盘中。</p>
<p>重新生成：mysql停止或重启；flush logs；超过max_binlog_size</p>
<h3 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h3><ol>
<li><strong>sql优化</strong></li>
</ol>
<p>避免使用select *</p>
<p>使用union all代替union</p>
<p>小表驱动大表</p>
<p>批量操作不要写循环</p>
<p>多用limit</p>
<p>增量查询：每次只同步一批数据，这一批数据只有100条记录。每次同步完成之后，保存这100条数据中最大的id和时间，给同步下一批数据的时候用。</p>
<p>连接查询代替子查询</p>
<p>参数是子查询时，使用 EXISTS 代替 IN：可以用到索引、in需要扫描整张表</p>
<p>join的表不要过多</p>
<p>索引优化：explain</p>
<p>能用where不用having</p>
<p>避免使用否定形式</p>
<ol start="2">
<li>慢查询可能原因</li>
</ol>
<p>数据量过大、索引问题、锁问题、IO吞吐量小</p>
<ol start="3">
<li><strong>慢查询优化</strong></li>
</ol>
<p>使用选择性高的字段并前置（能过滤较多记录）</p>
<p>尽量使用覆盖索引</p>
<p>索引失效：组合索引左匹配原则、发生<strong>隐式转换</strong>、组合索引，in + order by in会阻断排序用索引、范围查询会阻断组合索引,索引涉及到范围查询的索引字段要放在组合索引的最后面、前<strong>模糊匹配</strong>导致索引失效、<strong>or查询</strong>，查询条件部分有索引，部分无索引，导致索引失效、查询条件使用了<strong>函数运算</strong>、四则运算等、使用了!&#x3D;、not in、选择性过低、asc和desc混用</p>
<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><ol>
<li><strong>本地缓存</strong></li>
</ol>
<p>Ehcache 、Guava Cache 、Spring Cache、Caffeine（常用）</p>
<p>缺点：不利于分布式架构、容量受部署的机器限制</p>
<ol start="2">
<li><strong>分布式缓存</strong></li>
</ol>
<p>缺点：复杂性提高，开发成本增加</p>
<p>方法：MEmcached、Redis</p>
<ol start="3">
<li><strong>多级缓存</strong></li>
</ol>
<p>本地缓存（速度快）+分布式缓存</p>
<p>使用场景：数据稳定、访问量大</p>
<h3 id="Redis基础"><a href="#Redis基础" class="headerlink" title="Redis基础"></a>Redis基础</h3><ol>
<li><strong>redis的功能</strong></li>
</ol>
<p>键值存储，内存缓存，分布式锁，限流，消息队列（5.0新增数据结构stream，可以做轻量级）</p>
<ol start="2">
<li><strong>做缓存</strong></li>
</ol>
<p>读写性能高、高并发处理、多种数据类型、数据持久化、高可用性</p>
<ol start="3">
<li><strong>分布式缓存</strong></li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th>支持的数据结构</th>
<th>数据持久化</th>
<th>性能、可扩展性</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>memcached</td>
<td>只支持键值对</td>
<td>不支持</td>
<td>多线程</td>
<td></td>
</tr>
<tr>
<td>redis</td>
<td>字符串、哈希表、列表、集合、有序集合</td>
<td>RDB\AOF</td>
<td>单线程</td>
<td></td>
</tr>
</tbody></table>
<ol start="4">
<li>支持的数据类型</li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th>应用</th>
<th>底层</th>
</tr>
</thead>
<tbody><tr>
<td>string</td>
<td>常规数据、计数</td>
<td>SDS（自己创建）</td>
</tr>
<tr>
<td>list</td>
<td>信息流、消息队列</td>
<td>双向链表</td>
</tr>
<tr>
<td>set</td>
<td>不能重复的数据</td>
<td>压缩列表+整数集合</td>
</tr>
<tr>
<td>hash</td>
<td>用户信息</td>
<td>数组+链表</td>
</tr>
<tr>
<td>zset</td>
<td>排序</td>
<td>跳跃表+压缩列表</td>
</tr>
<tr>
<td>bitmap</td>
<td>保存状态（0\1）</td>
<td>连续二进制</td>
</tr>
<tr>
<td>hyperloglogs</td>
<td>大数据统计</td>
<td></td>
</tr>
<tr>
<td>geospatial</td>
<td>附近的人</td>
<td>sort set</td>
</tr>
</tbody></table>
<ol start="4">
<li>为什么速度快？</li>
</ol>
<p>基于内存，内存访问速度远快于磁盘；</p>
<p>单线程+IO多路复用</p>
<p>数据结构优化</p>
<h3 id="redis应用"><a href="#redis应用" class="headerlink" title="redis应用"></a>redis应用</h3><ol>
<li><strong>redis做统计网站的uv</strong></li>
</ol>
<p>使用HyperLogLog，HyperLogLog是一种基数（cardinality）估算算法，可以用来统计大数据集合的不同元素个数，而不需要将所有元素都存储在内存中。它的优点是占用内存小，计算速度快，适合处理大规模的数据集。</p>
<p>可以通过将每个用户的IP地址作为HyperLogLog的元素进行去重计数，从而得到网站的UV。有一定误差。</p>
<ol start="2">
<li><strong>redis做排行版</strong></li>
</ol>
<p>使用有序集合（sorted set）数据结构来存储每个用户的分数和排名信息。</p>
<p>有序集合是一种有序的键值对集合，其中每个键关联着一个分数值，可以根据分数值对集合中的键进行排序。在排行榜中，可以将每个用户的得分作为有序集合中的分数，将用户ID作为有序集合中的键，然后根据分数值对有序集合进行排序，得到用户的排名信息。</p>
<h3 id="redis线程模式"><a href="#redis线程模式" class="headerlink" title="redis线程模式"></a>redis线程模式</h3><ol>
<li><strong>单线程模式</strong></li>
</ol>
<p>优点：简短高效、确保数据一致、支持原子性操作</p>
<p>缺点：单核限制、io限制、长时间阻塞</p>
<p>改进：IO多路复用、异步处理机制、高效数据结构、协议简单</p>
<ol start="2">
<li><strong>多线程模式</strong></li>
</ol>
<p>提高网络IO读写性能</p>
<ol start="3">
<li>为什么不用多线程？</li>
</ol>
<p>单线程容易维护、Redis的性能瓶颈是内存和网络不在Cpu上、多线程容易带来死锁上下文切换问题影响性能</p>
<ol start="4">
<li>为什么又用多线程？</li>
</ol>
<p>提高网络IO性能只应用在了网络数据的读写上</p>
<h3 id="redis内存管理"><a href="#redis内存管理" class="headerlink" title="redis内存管理"></a>redis内存管理</h3><ol>
<li><strong>过期数据处理</strong></li>
</ol>
<p>设置缓存数据过期时间、设置过期字典。</p>
<p>删除策略：</p>
<p>惰性删除是Redis默认的过期数据删除策略。当一个键值对过期时，并不会立即从内存中删除，而是在下一次访问该键值对时检查其是否过期，如果已过期，则删除。这种删除策略的好处是可以减少内存的碎片化，因为过期键值对的内存空间可以被重复利用。但是，它的缺点是可能会导致内存中存在大量的过期键值对，占用了大量的内存空间，并且检查过期键值对会对性能产生一定的影响。</p>
<p>定期删除是Redis另一种常用的过期数据删除策略。在这种策略下，Redis会定期（每秒钟）随机选择一些过期键值对进行删除。这种策略的好处是可以避免内存中存在大量的过期键值对，从而提高了内存的利用率，并且对性能的影响比惰性删除要小。但是，它的缺点是会造成一定的内存碎片化，因为删除操作可能会产生一些不连续的空闲内存块。</p>
<ol start="2">
<li><strong>内存淘汰机制</strong></li>
</ol>
<p>noeviction：当内存不足以容纳新写入数据时，新写入操作会报错；</p>
<p>volatile-lru：从已设置过期时间的数据集中挑选最近最少使用的数据淘汰；</p>
<p>volatile-ttl：从已设置过期时间的数据集中挑选将要过期的数据淘汰；</p>
<p>volatile-random：从已设置过期时间的数据集中任意选择数据淘汰；</p>
<p>allkeys-lru：从数据集中挑选最近最少使用的数据淘汰</p>
<p>volatile-lfu：最近不经常使用的原则，但只对设置了过期时间的键进行淘汰</p>
<ol start="3">
<li><strong>内存碎片</strong></li>
</ol>
<p>内存碎片是指空闲内存块之间存在无法利用的小块空闲内存的现象。</p>
<p>原因：频繁的内存分配和释放。内存对齐（整块分配）。大量缓存数据的更新。</p>
<p>避免：减少内存分配和释放的次数；合理设置内存对齐参数；定期清理内存碎片</p>
<h3 id="redis持久化机制"><a href="#redis持久化机制" class="headerlink" title="redis持久化机制"></a>redis持久化机制</h3><ol>
<li><strong>RDB持久化</strong></li>
</ol>
<p>RDB持久化是将Redis的数据集以快照的方式写入磁盘。当Redis需要保存数据时，它会将当前数据集写入一个RDB文件中。RDB文件包含了Redis在某个时间点上的数据快照，可以通过加载RDB文件来恢复数据。RDB持久化适用于数据集较大、对数据完整性要求不高的场景。</p>
<ol start="2">
<li><strong>AOF持久化</strong></li>
</ol>
<p>AOF持久化是将Redis的操作日志以追加的方式写入磁盘。每个Redis命令都会被追加到AOF文件的末尾。当Redis需要恢复数据时，它会按照AOF文件的顺序重新执行所有命令。AOF持久化适用于对数据完整性要求高的场景，因为它可以确保Redis的操作日志与实际执行的命令是一致的。</p>
<ol start="3">
<li><strong>RDB&amp;AOF混合持久化</strong></li>
</ol>
<h3 id="redis事务"><a href="#redis事务" class="headerlink" title="redis事务"></a>redis事务</h3><ol>
<li><strong>redis事务的缺点</strong></li>
</ol>
<p>原子性问题：Redis事务并不是严格的原子性操作，即使在一个事务中发生错误，已经执行的命令也不会回滚。</p>
<p>隔离性问题：Redis事务也不是严格的隔离性操作。在多个客户端同时执行事务时，如果它们修改了相同的键，可能会发生竞态条件（race condition），导致最终结果出现错误。</p>
<p>性能问题：Redis事务在执行期间会将所有命令放到一个队列中，然后一次性执行。</p>
<ol start="2">
<li><strong>解决方法</strong></li>
</ol>
<p>lua脚本可以实现事务和原子性操作，可以保证一些复杂的操作的数据一致性和原子性。</p>
<p>通过watch机制解决原子性问题、使用Redis的乐观锁机制解决隔离性问题</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ol>
<li><strong>缓存穿透、缓存击穿</strong></li>
</ol>
<p>缓存穿透通常指在缓存和存储层中都不存在数据，导致每次请求都要查询存储层。如果数据库中存在数据，但缓存中不存在，这种情况通常被称为缓存击穿。</p>
<p><strong>解决方法</strong>：</p>
<p>缓存空对象：将缓存中不存在的数据缓存为空对象，避免缓存穿透。</p>
<p>布隆过滤器：在缓存层上使用布隆过滤器，过滤掉一些明显不存在的数据请求，避免请求到存储层。</p>
<p>数据预热：在应用启动时，将热门数据预先加载到缓存中，避免请求到存储层。</p>
<p>设置缓存时间：对于不太可能存在的数据，可以设置一个较短的缓存时间，从而降低缓存穿透的概率。</p>
<p><em>布隆过滤器：布隆过滤器是一种概率型数据结构，用于判断一个元素是否可能存在于一个集合中。它可以快速判断一个元素是否存在于一个大型集合中，而无需对整个集合进行遍历和比较。</em></p>
<p><em>布隆过滤器基于位数组和多个哈希函数构成。当一个元素被加入集合时，将会被多个哈希函数映射成多个位数组上的位置，并将这些位置标记为1。当判断一个元素是否存在于集合时，将该元素经过哈希函数映射到多个位数组上，如果所有位置的值都为1，则认为该元素可能存在于集合中；如果有任何一个位置的值为0，则认为该元素一定不存在于集合中。</em></p>
<p><em>由于布隆过滤器存在一定的误判率，因此它适合于那些可以容忍一定误判率的场景，如缓存穿透的解决方案等。</em></p>
<ol start="2">
<li><strong>缓存雪崩</strong></li>
</ol>
<p>缓存雪崩是指缓存中大量的数据在同一时间过期失效，导致请求直接访问存储层，从而导致存储层的瞬时压力骤增，甚至会导致存储层宕机的情况。</p>
<p>解决方法：为缓存数据设置不同的过期时间，防止同时失效；在缓存数据过期前，异步更新缓存，避免大量缓存同时失效</p>
<ol start="3">
<li><strong>读写策略</strong></li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th>读</th>
<th>写</th>
</tr>
</thead>
<tbody><tr>
<td>Cache-Aside（旁路缓存）</td>
<td></td>
<td>先写数据库中，再写入缓存</td>
</tr>
<tr>
<td>Write-Through（透写缓存）</td>
<td></td>
<td>先写缓存，再写数据库</td>
</tr>
<tr>
<td>Write-Back（回写缓存）</td>
<td></td>
<td>先写缓存标记脏数据，等待进程写入1数据库</td>
</tr>
</tbody></table>
<h3 id="redis集群"><a href="#redis集群" class="headerlink" title="redis集群"></a>redis集群</h3><ol>
<li><strong>如何保证高可用</strong></li>
</ol>
<p>主从复制：master主节点负责处理写请求，slave从节点负责处理读请求。master宕机，选择一台slave作为master将主节点数据复制到从节点，保障高可用，实现读写分离提高并发量</p>
<p>sentinel哨兵</p>
<p>sentinel可以监控redis节点运行状态并自动完成故障转移</p>
<p>分布式系统：多个sentinel节点投票决定master节点是否不可用，sentienl是高可用</p>
<p>运行方式：sentinel节点每秒钟向master和slave发送ping，超时未回复则认为线下。slave下线不关心，如果master超时回复，则多个sentinel进行核实。一旦下线，则会选择一个slave作为新的master，选择slave的规则：</p>
<ul>
<li><p>slave优先级：手动设置</p>
</li>
<li><p>复制进度：选择最相似的</p>
</li>
<li><p>运行id：选择较小的</p>
</li>
</ul>
<p>Redis Cluster</p>
<p>使用原因：缓存数据量大、并发量高</p>
<p>定义：部署多台Redis主节点，同时提供读写服务，可以为每一个master再配置slave</p>
<p>优点：横向扩充动态扩容缩容（直接添加或者删除节点）</p>
<p>​			具备主从复制、故障转移（内置sentinel机制）</p>
<p>基本要求：3个master、个slave</p>
<p>分片：哈希槽分区每个键值对属于一个哈希槽，共有16384个哈希槽，自动分配哈希槽到各个节点</p>
<ol start="2">
<li><strong>Redis Cluster如何实现各节点数据一致性</strong></li>
</ol>
<p>Redis Cluster使用Gossip协议来保持集群节点之间的通信和状态同步。每个节点定期地向其他节点发送信息，包括自己的状态、所知道的其他节点信息等。当节点接收到其他节点的信息时，它会将这些信息与自己的信息进行比对，以确保数据的一致性。</p>
<ol start="3">
<li><strong>虚拟槽分区</strong></li>
</ol>
<p>Redis Cluster中采用了虚拟槽分区的方式来实现数据的分片和负载均衡。具体来说，Redis Cluster将整个数据集划分为16384个槽，每个节点可以负责多个槽。当一个节点加入或离开集群时，它会和其他节点交换槽信息，确保每个节点都知道哪些槽分配给了哪个节点。当客户端对集群进行读写操作时，Redis会根据Key所属的槽位，将请求转发到负责该槽位的节点上进行处理。这样，就实现了数据的分片和负载均衡。同时，为了确保数据的高可用性，每个槽位都会有多个副本（通常是3个），即使某个节点宕机，数据仍然可以通过其它副本进行读写。</p>
<h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><ol>
<li>命令执行步骤</li>
</ol>
<p>发送命令、命令排队、命令执行、返回结果</p>
<p>优化方式：批量操作、lua脚本</p>
<h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h1><ol>
<li><strong>#{} 和 ${} 的区别是什么？</strong></li>
</ol>
<p>#{} 会将传入的参数都转义为一个占位符“？”并且使用 JDBC 的 PreparedStatement 对占位符进行赋值，从而避免 SQL 注入的风险。</p>
<p>${} 则是直接进行字符串替换，不会对传入的参数进行预编译处理，因此存在 SQL 注入的风险。</p>
<ol start="2">
<li><strong>xml 映射文件中，除了常见的 select、insert、update、delete 标签之外，还有哪些标签？</strong></li>
</ol>
<p><code>&lt;resultMap&gt;</code> 、 <code>&lt;parameterMap&gt;</code> 、 <code>&lt;sql&gt;</code> 、 <code>&lt;include&gt;</code> 、 <code>&lt;selectKey&gt;</code> ，加上动态 sql 的 9 个标签， <code>trim|where|set|foreach|if|choose|when|otherwise|bind</code> 等，其中 <code>&lt;sql&gt;</code> 为 sql 片段标签，通过 <code>&lt;include&gt;</code> 标签引入 sql 片段， <code>&lt;selectKey&gt;</code> 为不支持自增的主键生成策略标签。</p>
<ol start="3">
<li><strong>Dao</strong>接口的工作原理是什么？Dao 接口里的方法，参数不同时，方法能重载吗？</li>
</ol>
<p>Dao 接口里的方法可以重载，但是 Mybatis 的 xml 里面的 ID 不允许重复。</p>
<ol start="4">
<li><strong>分页功能</strong></li>
</ol>
<p><strong>(1)</strong> MyBatis 使用 RowBounds 对象进行分页，它是针对 ResultSet 结果集执行的内存分页，而非物理分页；</p>
<p><strong>(2)</strong> 可以在 sql 内直接书写带有物理分页的参数来完成物理分页功能，</p>
<p><strong>(3)</strong> 也可以使用分页插件来完成物理分页。</p>
<p>分页插件的基本原理是使用 MyBatis 提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的 sql，然后重写 sql，根据 dialect 方言，添加对应的物理分页语句和物理分页参数。</p>
<ol start="5">
<li><strong>动态SQL</strong></li>
</ol>
<p>动态 SQL 是指在 SQL 语句中根据条件动态拼接 SQL 语句的技术，通常用于构建复杂的查询语句。种类：<code>&lt;if&gt;``&lt;where&gt;``&lt;choose&gt;``&lt;foreach&gt;``&lt;bind/&gt;</code></p>
<ol start="6">
<li>缓存</li>
</ol>
<p>一级缓存：SqlSession级别</p>
<p>二级缓存：SqlSessionFactory级别  </p>
<p>增删改会失效，先查二级再查一级</p>
<ol start="7">
<li>分页插件</li>
</ol>
<p>RowBounds、PageHelper（推荐）</p>
<p>原理：获取分页参数、拦截查询Sql语句，根据参数添加查询条件LIMIT、封装对象并返回</p>
<h3 id="mybatis-plus"><a href="#mybatis-plus" class="headerlink" title="mybatis-plus"></a>mybatis-plus</h3><ol>
<li><strong>注解</strong></li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th>作用</th>
<th>参数</th>
</tr>
</thead>
<tbody><tr>
<td>@TableName</td>
<td>实体类标识对应表</td>
<td>表名</td>
</tr>
<tr>
<td>@TableID</td>
<td>属性标识主键</td>
<td>属性</td>
</tr>
<tr>
<td>@TableField</td>
<td>属性名标识字段名</td>
<td>字段名</td>
</tr>
<tr>
<td>@TableLogic</td>
<td>逻辑删除</td>
<td></td>
</tr>
</tbody></table>
<ol start="2">
<li><strong>主键生成策略</strong></li>
</ol>
<p>自动增长、uuid（排序困难）、redis生成（固定步长增加）、雪花算法</p>
<p>雪花算法：时间戳+数据中心ID+机器ID+序列号</p>
<ol start="3">
<li>插件</li>
</ol>
<p>分页插件</p>
<p>乐观锁：基于版本号机制</p>
<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h3 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h3><p><strong>IoC（Inversion of Control:控制反转）</strong> 是一种设计思想，而不是一个具体的技术实现。IoC 的思想就是将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理。</p>
<ul>
<li><strong>控制</strong> ：指的是对象创建（实例化、管理）的权力</li>
<li><strong>反转</strong> ：控制权交给外部环境（Spring 框架、IoC 容器）</li>
</ul>
<p>好处：对象之间的耦合度或者说依赖程度降低；资源变的容易管理；比如你用 Spring 容器提供的话很容易就可以实现一个单例</p>
<ol start="2">
<li>IOC和DI区别</li>
</ol>
<p>IoC（Inverse of Control:控制反转）是一种<strong>设计思想</strong> 或者说是某种模式。这个设计思想就是 <strong>将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理。</strong> IoC 在其他语言中也有应用，并非 Spring 特有。<strong>IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个 Map（key，value）,Map 中存放的是各种对象。</strong></p>
<p>IoC 最常见以及最合理的实现方式叫做依赖注入（Dependency Injection，简称 DI）。</p>
<h3 id="Bean"><a href="#Bean" class="headerlink" title="Bean"></a>Bean</h3><ol start="0">
<li>注入方式</li>
</ol>
<p>构造方法注入、setter注入</p>
<ol>
<li><p>概念：Bean 代指的就是那些被 IoC 容器所管理的对象</p>
</li>
<li><p>注解：</p>
</li>
</ol>
<p><code>@Component</code> ：通用的注解，可标注任意类为 <code>Spring</code> 组件。如果一个 Bean 不知道属于哪个层，可以使用<code>@Component</code> 注解标注。</p>
<p><code>@Repository</code> : 对应持久层即 Dao 层，主要用于数据库相关操作。</p>
<p><code>@Service</code> : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。</p>
<p><code>@Controller</code> : 对应 Spring MVC 控制层，主要用于接受用户请求并调用 <code>Service</code> 层返回数据给前端页面</p>
<ol start="3">
<li>@Component 和 @Bean 的区别是什么？</li>
</ol>
<ul>
<li><code>@Component</code> 注解作用于类，而<code>@Bean</code>注解作用于方法</li>
<li><code>@Component</code>通常是通过类路径扫描来自动侦测以及自动装配到 Spring 容器中，<code>@Bean</code> 注解通常是我们在标有该注解的方法中定义产生这个 bean</li>
<li><code>@Bean</code> 注解比 <code>@Component</code> 注解的自定义性更强，而且很多地方我们只能通过 <code>@Bean</code> 注解来注册 bean</li>
</ul>
<ol start="4">
<li>注入Bean</li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th>@Autowired</th>
<th>@Resource</th>
<th>@Inject</th>
</tr>
</thead>
<tbody><tr>
<td>来源</td>
<td>spring 内置</td>
<td>JDK提供</td>
<td></td>
</tr>
<tr>
<td>注入方式</td>
<td>默认byType</td>
<td>默认byName</td>
<td></td>
</tr>
<tr>
<td>多个实现类</td>
<td>通过 <code>@Qualifier</code> 注解来显式指定名称</td>
<td>通过 <code>name</code> 属性来显式指定名称</td>
<td></td>
</tr>
</tbody></table>
<ol start="5">
<li>作用域</li>
</ol>
<p><strong>singleton</strong> : IoC 容器中只有唯一的 bean 实例。Spring 中的 bean 默认都是单例的，是对单例设计模式的应用。</p>
<p><strong>prototype</strong> : 每次获取都会创建一个新的 bean 实例。也就是说，连续 <code>getBean()</code> 两次，得到的是不同的 Bean 实例。</p>
<p><strong>request</strong> （仅 Web 应用可用）: 每一次 HTTP 请求都会产生一个新的 bean（请求 bean），该 bean 仅在当前 HTTP request 内有效。</p>
<p><strong>session</strong> （仅 Web 应用可用） : 每一次来自新 session 的 HTTP 请求都会产生一个新的 bean（会话 bean），该 bean 仅在当前 HTTP session 内有效。</p>
<p><strong>application&#x2F;global-session</strong> （仅 Web 应用可用）： 每个 Web 应用在启动时创建一个 Bean（应用 Bean），该 bean 仅在当前应用启动时间内有效。</p>
<p><strong>websocket</strong> （仅 Web 应用可用）：每一次 WebSocket 会话产生一个新的 bean。</p>
<ol start="6">
<li>生命周期</li>
</ol>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230508191347978.png" alt="image-20230508191347978"></p>
<p>初始化前、初始化后的操作时未来修改或增强增强Bean，或者为Bean设置代理</p>
<h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p><strong>作用</strong>：在不改变原有业务逻辑的情况下，增强横切逻辑代码，根本上解耦合，避免横切逻辑代码重复。</p>
<p><strong>切面编程</strong>：</p>
<p><strong>切</strong> ：指的是横切逻辑，原有业务逻辑代码不动，只能操作横切逻辑代码，所以面向横切逻辑</p>
<p><strong>面</strong> ：横切逻辑代码往往要影响的是很多个方法，每个方法如同一个点，多个点构成一个面。这里有一个面的概念</p>
<p><strong>应用场景</strong>：</p>
<p>日志记录：通过AOP技术，可以在程序执行前、执行后或者抛出异常时记录日志，方便程序员在出现问题时快速定位问题。</p>
<p>安全控制：通过AOP技术，可以在程序执行前进行身份认证和权限控制，保证程序的安全性。</p>
<p>性能监控：通过AOP技术，可以在程序执行前、执行后或者抛出异常时统计程序的执行时间和消耗资源，以便优化程序性能。</p>
<p>缓存控制：通过AOP技术，可以在程序执行前、执行后或者抛出异常时对数据进行缓存操作，提高程序性能。</p>
<p>事务管理：通过AOP技术，可以在程序执行前开启事务，在程序执行后提交或者回滚事务，保证数据的一致性和完整性。</p>
<p>异常处理：通过AOP技术，可以在程序抛出异常时进行处理，如记录日志、提示用户等，提高程序的可靠性和稳定性。</p>
<h3 id="事务-1"><a href="#事务-1" class="headerlink" title="事务"></a>事务</h3><ol>
<li>支持什么事务管理</li>
</ol>
<p>编程式事务（需要手动编写）、声明式事务（基于注解和基于xml）</p>
<ol start="2">
<li>事务管理接口</li>
</ol>
<p><strong>PlatformTransactionManager:事务管理接口</strong></p>
<p>Spring 并不直接管理事务，而是提供了多种事务管理器。</p>
<p><strong>TransactionDefinition:事务属性</strong></p>
<p>事务管理器接口 <strong><code>PlatformTransactionManager</code></strong> 通过 <strong><code>getTransaction(TransactionDefinition definition)</code></strong> 方法来得到一个事务，这个方法里面的参数是 <strong><code>TransactionDefinition</code></strong> 类 ，这个类就定义了一些基本的事务属性。</p>
<p><strong>TransactionStatus:事务状态</strong></p>
<p><code>TransactionStatus</code>接口用来记录事务的状态 该接口定义了一组方法,用来获取或判断事务的相应状态信息。</p>
<h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><h1 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h1><p>MVC 是模型(Model)、视图(View)、控制器(Controller)的简写，其核心思想是通过将业务逻辑、数据、显示分离来组织代码。</p>
<ol>
<li>核心组件</li>
</ol>
<p><strong><code>DispatcherServlet</code></strong> ：<strong>核心的中央处理器</strong>，负责接收请求、分发，并给予客户端响应。</p>
<p><strong><code>HandlerMapping</code></strong> ：<strong>处理器映射器</strong>，根据 uri 去匹配查找能处理的 <code>Handler</code> ，并会将请求涉及到的拦截器和 <code>Handler</code> 一起封装。</p>
<p><strong><code>HandlerAdapter</code></strong> ：<strong>处理器适配器</strong>，根据 <code>HandlerMapping</code> 找到的 <code>Handler</code> ，适配执行对应的 <code>Handler</code>；</p>
<p><strong><code>Handler</code></strong> ：<strong>请求处理器</strong>，处理实际请求的处理器。</p>
<p><strong><code>ViewResolver</code></strong> ：<strong>视图解析器</strong>，根据 <code>Handler</code> 返回的逻辑视图 &#x2F; 视图，解析并渲染真正的视图，并传递给 <code>DispatcherServlet</code> 响应客户</p>
<ol start="2">
<li>执行流程</li>
</ol>
<ul>
<li><p>客户端（浏览器）发送请求， <code>DispatcherServlet</code>拦截请求。</p>
</li>
<li><p><code>DispatcherServlet</code> 根据请求信息调用 <code>HandlerMapping</code> 。<code>HandlerMapping</code> 根据 uri 去匹配查找能处理的 <code>Handler</code>（也就是我们平常说的 <code>Controller</code> 控制器） ，并会将请求涉及到的拦截器和 <code>Handler</code> 一起封装。</p>
</li>
<li><p><code>DispatcherServlet</code> 调用 <code>HandlerAdapter</code>适配执行 <code>Handler</code> 。</p>
</li>
<li><p><code>Handler</code> 完成对用户请求的处理后，会返回一个 <code>ModelAndView</code> 对象给<code>DispatcherServlet</code>，<code>ModelAndView</code> 顾名思义，包含了数据模型以及相应的视图的信息。<code>Model</code> 是返回的数据对象，<code>View</code> 是个逻辑上的 <code>View</code>。</p>
</li>
<li><p><code>ViewResolver</code> 会根据逻辑 <code>View</code> 查找实际的 <code>View</code>。</p>
</li>
<li><p><code>DispaterServlet</code> 把返回的 <code>Model</code> 传给 <code>View</code>（视图渲染）。</p>
</li>
<li><p>把 <code>View</code> 返回给请求者（浏览器）</p>
</li>
</ul>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230505221632054.png" alt="image-20230505221632054"></p>
<h1 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h1><ol start="0">
<li>SpringMVC和SpringBoot之间的区别</li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th>springmvc</th>
<th>springboot</th>
</tr>
</thead>
<tbody><tr>
<td>项目结构</td>
<td>手动配置</td>
<td>约定优先于配置</td>
</tr>
<tr>
<td>配置方式</td>
<td>xml或java代码</td>
<td>自动配置</td>
</tr>
<tr>
<td>依赖管理</td>
<td>手动引入</td>
<td>集成第三方依赖</td>
</tr>
<tr>
<td>对外提供服务</td>
<td>部署在web容器</td>
<td>打包jar、war</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<ol>
<li>对象之间的耦合度或者说依赖程度降低；</li>
<li>资源变的容易管理；比如你用 Spring 容器提供的话很容易就可以实现一个单例</li>
</ol>
<h3 id="注解-1"><a href="#注解-1" class="headerlink" title="注解"></a>注解</h3><ol>
<li><strong>SpringBootApplication</strong></li>
</ol>
<ul>
<li><code>@SpringBootConfiguration</code>：表示该类是 Spring Boot 应用程序的配置类。</li>
<li><code>@EnableAutoConfiguration</code>：表示启用自动配置机制，根据类路径中的依赖项和其他 Bean 的存在来猜测和配置 Bean。</li>
<li><code>@ComponentScan</code>：表示扫描当前包及其子包以查找其他组件、配置和服务。</li>
</ul>
<ol start="2">
<li><strong>restful web常用注解</strong></li>
</ol>
<p>spring bean相关：</p>
<ul>
<li><p><code>@Autowired</code>自动导入对象到类中，被注入进的类同样要被 Spring 容器管理</p>
</li>
<li><p><code>@Component</code> ：通用的注解，可标注任意类为 <code>Spring</code> 组件。</p>
</li>
<li><p><code>@Repository</code> : 对应持久层即 Dao 层，主要用于数据库相关操作。</p>
</li>
<li><p><code>@Controller</code> : 对应 Spring MVC 控制层，主要用于接受用户请求并调用 Service 层返回数据给前端页面。</p>
</li>
<li><p><code>@Service</code> : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。</p>
</li>
<li><p><code>@RestController</code>注解是<code>@Controller</code>和<code>@ResponseBody</code>的合集,表示这是个控制器 bean,并且是将函数的返回值直接填入 HTTP 响应体中,是 REST 风格的控制器。</p>
</li>
<li><p><code>@Configuration</code>一般用来声明配置类，可以使用 <code>@Component</code>注解替代，不过使用<code>@Configuration</code>注解声明配置类更加语义化。</p>
</li>
</ul>
<p>处理http请求类型：</p>
<p>​		GET	POST	PUT	DELETE</p>
<ol start="3">
<li><strong>前后端传值</strong></li>
</ol>
<ul>
<li><code>@PathVariable</code>用于获取路径参数<code>&quot;/users/&#123;id&#125;&quot;</code>，<code>@RequestParam</code>用于获取查询参数 <code>/users?page=1&amp;size=10</code> 。</li>
<li><code>@RequestBody</code>用于读取 Request 请求（可能是 POST,PUT,DELETE,GET 请求）的 body 部分并且<strong>Content-Type 为 application&#x2F;json</strong> 格式的数据，接收到数据之后会自动将数据绑定到 Java 对象上去。系统会使用<code>HttpMessageConverter</code>或者自定义的<code>HttpMessageConverter</code>将请求的 body 中的 json 字符串转换为 java 对象。</li>
</ul>
<ol start="4">
<li><strong>Bean作用域</strong></li>
</ol>
<ul>
<li>singleton : 唯一 bean 实例，Spring 中的 bean 默认都是单例的。</li>
<li>prototype : 每次请求都会创建一个新的 bean 实例。</li>
<li>request : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP request 内有效。</li>
<li>session : 每一个 HTTP Session 会产生一个新的 bean，该 bean 仅在当前 HTTP session 内有效。</li>
</ul>
<h3 id="配置信息"><a href="#配置信息" class="headerlink" title="配置信息"></a>配置信息</h3><ol>
<li><strong>读取配置信息</strong></li>
</ol>
<ul>
<li><code>@Value(&quot;$&#123;property&#125;&quot;)</code></li>
<li><code>@ConfigurationProperties</code></li>
<li><code>@PropertySource</code></li>
</ul>
<h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><ol>
<li><strong>optional标签</strong></li>
</ol>
<p>可选依赖，B依赖A（设置了optional标签），C依赖B，但是C不依赖A。</p>
<h3 id="自动装配流程"><a href="#自动装配流程" class="headerlink" title="自动装配流程"></a>自动装配流程</h3><ol>
<li>扫描并加载所有标注有 <code>@SpringBootApplication</code> 注解的类，其中包含 <code>@ComponentScan</code> 和 <code>@EnableAutoConfiguration</code> 注解。</li>
<li>在 <code>@ComponentScan</code> 扫描的包及其子包中查找所有的 <code>@Component</code>、<code>@Service</code>、<code>@Controller</code>、<code>@Repository</code> 等标注有注解的类，并将它们注册为Bean。</li>
<li>在 <code>@EnableAutoConfiguration</code> 扫描的包及其子包中查找所有的 <code>META-INF/spring.factories</code> 文件，并从中读取所有的自动装配的配置类。</li>
<li>根据读取到的配置类，依次尝试自动装配每个类，将其注入到Spring容器中。</li>
<li>自动装配的过程中，会根据默认的规则和策略来确定需要装配的Bean，如果有多个Bean符合条件，会根据优先级和特定的规则来选择最终的Bean。</li>
<li>最终，Spring Boot会将所有的Bean注册到Spring容器中，并自动配置好相应的依赖项。</li>
</ol>
<h3 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//MainApplication.java</span>

<span class="token annotation punctuation">@SpringBootApplication</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MainApplication</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token class-name">SpringApplication</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">MainApplication</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>构建了一个<code>SpringApplication</code>对象，然后再调用其<code>run</code>方法来启动SpringBoot项目</p>
<p>步骤：</p>
<ul>
<li>从<code>spring.factories</code>配置文件中<strong>加载</strong><code>EventPublishingRunListener</code><strong>对象</strong>，该对象拥有<code>SimpleApplicationEventMulticaster</code>属性，即在SpringBoot启动过程的不同阶段用来发射内置的生命周期事件;</li>
<li><strong>准备环境变量</strong>，包括系统变量，环境变量，命令行参数，默认变量，<code>servlet</code>相关配置变量，随机值以及配置文件（比如<code>application.properties</code>）等;</li>
<li>控制台<strong>打印SpringBoot的</strong><code>**bannner**</code><strong>标志</strong>；</li>
<li><strong>根据不同类型环境创建不同类型的</strong><code>**applicationcontext**</code><strong>容器</strong></li>
<li>从<code>spring.factories</code>配置文件中<strong>加载</strong><code>**FailureAnalyzers**</code><strong>对象</strong>,用来报告SpringBoot启动过程中的异常；</li>
<li><strong>为刚创建的容器对象做一些初始化工作</strong>，准备一些容器属性值等，对<code>ApplicationContext</code>应用一些相关的后置处理和调用各个<code>ApplicationContextInitializer</code>的初始化方法来执行一些初始化逻辑等；</li>
<li><strong>刷新容器</strong></li>
<li><strong>执行刷新容器后的后置处理逻辑</strong></li>
<li><strong>调用</strong><code>**ApplicationRunner**</code><strong>和</strong><code>**CommandLineRunner**</code><strong>的run方法</strong>，我们实现这两个接口可以在spring容器启动后需要的一些东西比如加载一些业务数据等;</li>
<li><strong>报告启动异常</strong>，即若启动过程中抛出异常，此时用<code>FailureAnalyzers</code>来报告异常;</li>
<li><strong>返回容器对象</strong></li>
</ul>
<h3 id="参数校验"><a href="#参数校验" class="headerlink" title="参数校验"></a>参数校验</h3><p>校验注解：JSR校验注解、Hibernate Validator校验注解</p>
<p>验证请求体：参数前加<code>@Valid</code>注解</p>
<p>验证请求参数：类前加<code>@Validated</code>注解</p>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><h3 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h3><p><code>@Scheduled</code>注解加在方法上，<code>@EnableScheduling</code>注解加在启动类上</p>
<ol>
<li>过滤器和拦截器的区别</li>
</ol>
<ul>
<li>拦截器是基于Java的反射机制的，而过滤器是基于函数回调的</li>
<li>过滤器是基于 Servlet 规范实现的，而拦截器是基于 Spring 框架的</li>
<li>过滤器只能对请求进行处理，而拦截器可以对请求和响应都进行处理</li>
<li>过滤器在请求进入 Servlet 容器之前处理请求，而拦截器在请求进入 Spring MVC 控制器之前进行处理</li>
<li>过滤器可以修改请求参数，拦截器不能修改请求参数，只能修改请求头和请求体中的数据</li>
<li>过滤器的使用场景比较单一，一般用于对请求进行预处理，例如字符编码、日志记录等；而拦截器的使用场景比较广泛，可以用于权限校验、日志记录、性能监控、流量控制等</li>
<li>过滤器可以配置在 web.xml 文件中，而拦截器需要在 Spring 配置文件中进行配置</li>
</ul>
<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h3 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h3><ol>
<li><strong>OSI</strong></li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>物理层</td>
<td>主要负责数据的传输和接收，以及网络中的电气、机械和功能特性等硬件层面的定义。</td>
</tr>
<tr>
<td>数据链路层</td>
<td>负责在相邻的节点之间传输数据，通过在数据帧中添加标识符和校验和来保证数据的可靠传输，同时还可以控制访问介质（如局域网）。</td>
</tr>
<tr>
<td>网络层</td>
<td>负责数据包在网络中的路由选择和转发，通过IP协议实现不同网络之间的连接和通信。</td>
</tr>
<tr>
<td>传输层</td>
<td>提供可靠的端到端数据传输服务，通过TCP协议（面向连接）和UDP协议（无连接）来实现数据的分段传输、流量控制和错误恢复等功能。</td>
</tr>
<tr>
<td>会话层</td>
<td>负责建立、管理和终止应用程序之间的会话，确保数据在传输过程中的顺序、完整性和可靠性。</td>
</tr>
<tr>
<td>表示层</td>
<td>负责数据的格式化和编码，以便不同的应用程序能够相互理解和交换数据。</td>
</tr>
<tr>
<td>应用层</td>
<td>为用户提供网络服务，包括电子邮件、文件传输、Web访问等，同时也是用户和网络之间的接口。</td>
</tr>
</tbody></table>
<ol start="2">
<li><strong>OSI模型缺点</strong></li>
</ol>
<p>理论复杂、实现困难、缺乏灵活性、过于理论化、失去实际意义</p>
<ol start="3">
<li><strong>TCP\IP模型</strong></li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>网络接口层</td>
<td>负责在物理网络上实现数据传输，主要使用以太网等协议</td>
</tr>
<tr>
<td>网络层</td>
<td>负责在不同网络之间传输数据包，使用IP协议实现不同网络之间的连接和通信</td>
</tr>
<tr>
<td>传输层</td>
<td>提供端到端的可靠数据传输服务，同时还提供流量控制和错误恢复等功能</td>
</tr>
<tr>
<td>应用层</td>
<td>提供应用程序与网络之间的接口，负责处理用户数据和应用程序数据的传输</td>
</tr>
</tbody></table>
<ol start="4">
<li><strong>网络分层的好处</strong></li>
</ol>
<p>各层之间相互独立、提高整体灵活性</p>
<h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><ol>
<li><strong>MAC地址</strong></li>
</ol>
<p>MAC地址（Media Access Control Address），也称为物理地址或硬件地址，是指网络设备（如网卡、交换机等）在出厂时预设的唯一标识符，用于标识网络设备之间的通信。MAC地址由48位二进制数字组成，通常用16进制数表示，例如00-1A-2B-3C-4D-5E。</p>
<p>MAC 地址有一个特殊地址：FF-FF-FF-FF-FF-FF（全 1 地址），该地址表示广播地址。</p>
<h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><ol>
<li><strong>TCP和UDP的区别</strong></li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th>TCP</th>
<th align="left">UDP</th>
</tr>
</thead>
<tbody><tr>
<td>是否面向连接</td>
<td>是</td>
<td align="left">否</td>
</tr>
<tr>
<td>是否可靠</td>
<td>是</td>
<td align="left">否</td>
</tr>
<tr>
<td>是否有状态</td>
<td>是</td>
<td align="left">否</td>
</tr>
<tr>
<td>传输效率</td>
<td>较慢</td>
<td align="left">较快</td>
</tr>
<tr>
<td>传输形式</td>
<td>字节流</td>
<td align="left">数据报文段</td>
</tr>
<tr>
<td>首部开销</td>
<td>20 ～ 60 bytes</td>
<td align="left">8 bytes</td>
</tr>
<tr>
<td>是否提供广播或多播服务</td>
<td>否</td>
<td align="left">是</td>
</tr>
<tr>
<td>使用场景</td>
<td>准确性要求高的场景，文件传输接收邮件</td>
<td align="left">即时通讯，直播音视频</td>
</tr>
<tr>
<td>上层协议</td>
<td>HTTP、HTTPS、FTP、SMTP、POP、IMAP、TELNET、SSH</td>
<td align="left">DNS、DHCP</td>
</tr>
</tbody></table>
<ol start="2">
<li><strong>TCP三握手四挥手</strong></li>
</ol>
<p>三握手：</p>
<p><strong>一次握手</strong>:客户端发送带有 SYN（SEQ&#x3D;x） 标志的数据包 -&gt; 服务端，然后客户端进入 <strong>SYN_SEND</strong> 状态，等待服务器的确认；</p>
<p><strong>二次握手</strong>:服务端发送带有 SYN+ACK(SEQ&#x3D;y,ACK&#x3D;x+1) 标志的数据包 –&gt; 客户端,然后服务端进入 <strong>SYN_RECV</strong> 状态</p>
<p><strong>三次握手</strong>:客户端发送带有 ACK(ACK&#x3D;y+1) 标志的数据包 –&gt; 服务端，然后客户端和服务器端都进入<strong>ESTABLISHED</strong> 状态，完成TCP三次握手。</p>
<p>四挥手：</p>
<p><strong>第一次挥手</strong> ：客户端发送一个 FIN（SEQ&#x3D;X） 标志的数据包-&gt;服务端，用来关闭客户端到服务器的数据传送。然后，客户端进入 <strong>FIN-WAIT-1</strong> 状态。</p>
<p><strong>第二次挥手</strong> ：服务器收到这个 FIN（SEQ&#x3D;X） 标志的数据包，它发送一个 ACK （SEQ&#x3D;X+1）标志的数据包-&gt;客户端 。然后，此时服务端进入<strong>CLOSE-WAIT</strong>状态，客户端进入<strong>FIN-WAIT-2</strong>状态。</p>
<p><strong>第三次挥手</strong> ：服务端关闭与客户端的连接并发送一个 FIN (SEQ&#x3D;y)标志的数据包-&gt;客户端请求关闭连接，然后，服务端进入<strong>LAST-ACK</strong>状态。</p>
<p><strong>第四次挥手</strong> ：客户端发送 ACK (SEQ&#x3D;y+1)标志的数据包-&gt;服务端并且进入<strong>TIME-WAIT</strong>状态，服务端在收到 ACK (SEQ&#x3D;y+1)标志的数据包后进入 CLOSE 状态。此时，如果客户端等待 <strong>2MSL</strong> 后依然没有收到回复，就证明服务端已正常关闭，随后，客户端也可以关闭连接了。</p>
<ol start="3">
<li><strong>客户端为什么等待2MSL时间</strong></li>
</ol>
<p>防止客户端的ACK包没有发送到服务器端，如果服务器没有收到就会重发FIN，然后客户端再发ACK并等待2MSL，防止服务端没有收到ACK一直等待</p>
<ol start="4">
<li><strong>TCP如何保证传输可靠性</strong></li>
</ol>
<p>应答机制、序列号、滑动窗口、超时重传</p>
<h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><ol start="0">
<li><strong>常见协议</strong></li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>HTTP</td>
<td><strong>超文本传输协议</strong> 主要是为 Web 浏览器与 Web 服务器之间的通信而设计的。</td>
</tr>
<tr>
<td>SMTP</td>
<td>发送电子邮件</td>
</tr>
<tr>
<td>POP3\IMAP</td>
<td>接收邮件</td>
</tr>
<tr>
<td>FTP</td>
<td>文件传输协议</td>
</tr>
<tr>
<td>Telnet</td>
<td>远程登陆协议（明文传输）</td>
</tr>
<tr>
<td>SSH（取代Telnet）</td>
<td>远程登录会话和其他网络服务提供安全性的协议</td>
</tr>
</tbody></table>
<ol>
<li><strong>HTTP3基于TCP还是UDP</strong></li>
</ol>
<p>HTTP 3.0 之前是基于 TCP 协议的，而 HTTP3.0 将弃用 TCP，改用 <strong>基于 UDP 的 QUIC 协议</strong> 。此变化主要为了解决 HTTP&#x2F;2 中存在的队头阻塞问题。由于 HTTP&#x2F;2 在单个 TCP 连接上使用了多路复用，受到 TCP 拥塞控制的影响，少量的丢包就可能导致整个 TCP 连接上的所有流被阻塞。</p>
<ol start="2">
<li><strong>HTTP和HTTPS</strong></li>
</ol>
<p><strong>端口号</strong> ：HTTP 默认是 80，HTTPS 默认是 443。</p>
<p><strong>URL 前缀</strong> ：HTTP 的 URL 前缀是 <code>http://</code>，HTTPS 的 URL 前缀是 <code>https://</code>。</p>
<p><strong>安全性和资源消耗</strong> ： HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS 是运行在 SSL&#x2F;TLS 之上的 HTTP 协议，SSL&#x2F;TLS 运行在 TCP 之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源。</p>
<ol start="3">
<li><strong>url输入到页面发生了什么？</strong></li>
</ol>
<p>DNS解析、TCP链接、发送HTTP请求、服务器处理返回HTTP报文、浏览器解析渲染页面、连接结束</p>
<ol start="4">
<li><strong>HTTP如何保存用户状态</strong></li>
</ol>
<p>session（会话）机制，可以储存再cookie和url中</p>
<ol start="5">
<li><strong>HTTP1.0和HTTP1.1</strong></li>
</ol>
<p><strong>连接方式</strong> : HTTP 1.0 为短连接，HTTP 1.1 支持长连接。</p>
<p><strong>状态响应码</strong> : HTTP&#x2F;1.1中新加入了大量的状态码，光是错误响应状态码就新增了24种。比如说，<code>100 (Continue)</code>——在请求大资源前的预热请求，<code>206 (Partial Content)</code>——范围请求的标识码，<code>409 (Conflict)</code>——请求与当前资源的规定冲突，<code>410 (Gone)</code>——资源已被永久转移，而且没有任何已知的转发地址。</p>
<p><strong>缓存处理</strong> : 在 HTTP1.0 中主要使用 header 里的 If-Modified-Since,Expires 来做为缓存判断的标准，HTTP1.1 则引入了更多的缓存控制策略例如 Entity tag，If-Unmodified-Since, If-Match, If-None-Match 等更多可供选择的缓存头来控制缓存策略。</p>
<p><strong>带宽优化及网络连接的使用</strong> :HTTP1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</p>
<p><strong>Host头处理</strong> : HTTP&#x2F;1.1在请求头中加入了<code>Host</code>字段。</p>
<ol start="6">
<li>session和cookie关系和区别</li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th>cookie</th>
<th>session</th>
</tr>
</thead>
<tbody><tr>
<td>存储位置</td>
<td>客户端浏览器</td>
<td>服务器内存磁盘</td>
</tr>
<tr>
<td>安全性</td>
<td>恶意用户窃取修改</td>
<td>相对更安全</td>
</tr>
<tr>
<td>传输方式</td>
<td>在每个HTTP请求中都会被发送到服务器端</td>
<td>只在用户首次访问服务器时传输一次，之后只需要传递Session ID</td>
</tr>
<tr>
<td>数据大小</td>
<td>一般为4KB左右</td>
<td>Session数据大小没有明确限制，但是过大的Session数据会占用服务器内存，影响系统性能。</td>
</tr>
<tr>
<td>有效期</td>
<td>可以设置过期时间，使得浏览器在一定时间后自动删除</td>
<td>通常会在用户关闭浏览器或超过一定时间后被自动删除</td>
</tr>
</tbody></table>
<ol start="7">
<li>Get和Post</li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th>作用</th>
<th>请求参数位置</th>
<th>长度限制</th>
<th>安全性</th>
<th>多次请求</th>
</tr>
</thead>
<tbody><tr>
<td>get</td>
<td>请求资源</td>
<td>url</td>
<td>有</td>
<td>低</td>
<td>结果相同</td>
</tr>
<tr>
<td>post</td>
<td>提交数据</td>
<td>请求体</td>
<td>无</td>
<td>高</td>
<td>不同</td>
</tr>
</tbody></table>
<h1 id="设计模式（OOP）"><a href="#设计模式（OOP）" class="headerlink" title="设计模式（OOP）"></a>设计模式（OOP）</h1><ol>
<li>设计模式的原则</li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>开闭原则</td>
<td>扩展开放、修改关闭</td>
</tr>
<tr>
<td>单一职责原则</td>
<td>一个类负责一个功能</td>
</tr>
<tr>
<td>里氏替换原则</td>
<td>所有引用基类的地方必须能透明使用其子类对象</td>
</tr>
<tr>
<td>依赖倒置原则</td>
<td>依赖抽象，不依赖具体实现</td>
</tr>
<tr>
<td>接口隔离原则</td>
<td>类之间依赖关系建立在最小接口上</td>
</tr>
<tr>
<td>合成聚合复用原则</td>
<td>尽量使用组合，而不是继承</td>
</tr>
<tr>
<td>迪米特法则</td>
<td>一个软件实体应该尽可能少的与其他实体发生相互作用</td>
</tr>
</tbody></table>
<ol start="2">
<li>设计模式分类</li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th>概念</th>
<th>种类</th>
</tr>
</thead>
<tbody><tr>
<td>创建型</td>
<td></td>
<td></td>
</tr>
<tr>
<td>结构型</td>
<td></td>
<td></td>
</tr>
<tr>
<td>行为型</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ol>
<li>spring</li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>单例模式</td>
<td>单例bean</td>
</tr>
<tr>
<td>工厂模式</td>
<td>beanfactory</td>
</tr>
<tr>
<td>代理模式</td>
<td>AOP</td>
</tr>
<tr>
<td>模板方法模式</td>
<td>JDBCTemplate</td>
</tr>
<tr>
<td>观察者模式</td>
<td>事件机制</td>
</tr>
<tr>
<td>适配器模式</td>
<td>HandlerAdapter</td>
</tr>
<tr>
<td>过滤器模式</td>
<td>Servlet Filter</td>
</tr>
</tbody></table>

                
            </div>
            <hr/>

            



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/Java/">
                                    <span class="chip bg-color">Java</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2023/04/26/gu-li-xue-yuan-zhi-shi-dian/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/1.jpg" class="responsive-img" alt="谷粒学院知识点">
                        
                        <span class="card-title">谷粒学院知识点</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2023-04-26
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            花溪悠悠
                            
                        </span>
                    </div>
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                本篇&nbsp;<i class="far fa-dot-circle"></i>
            </div>
            <div class="card">
                <a href="/2023/04/14/mian-shi-ti/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/5.jpg" class="responsive-img" alt="面试题">
                        
                        <span class="card-title">面试题</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2023-04-14
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            花溪悠悠
                            
                        </span>
                    </div>
                </div>

                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Java/">
                        <span class="chip bg-color">Java</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>


  <!-- 是否加载使用自带的 prismjs. -->
  <script type="text/javascript" src="/libs/prism/prism.min.js"></script>


<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>



    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="/libs/aplayer/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2023</span>
            
            <a href="/about" target="_blank">花溪悠悠</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            
            <br>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/ZyL0NG" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:1045139383@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1045139383" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1045139383" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 白天和黑夜主题 -->
<div class="stars-con">
    <div id="stars"></div>
    <div id="stars2"></div>
    <div id="stars3"></div>  
</div>

<script>
    function switchNightMode() {
        $('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($('body')),
        setTimeout(function () {
            $('body').hasClass('DarkMode') 
            ? ($('body').removeClass('DarkMode'), localStorage.setItem('isDark', '0'), $('#sum-moon-icon').removeClass("fa-sun").addClass('fa-moon')) 
            : ($('body').addClass('DarkMode'), localStorage.setItem('isDark', '1'), $('#sum-moon-icon').addClass("fa-sun").removeClass('fa-moon')),
            
            setTimeout(function () {
            $('.Cuteen_DarkSky').fadeOut(1e3, function () {
                $(this).remove()
            })
            }, 2e3)
        })
    }
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    
    
    

    <!-- 雪花特效 -->
    

    <!-- 鼠标星星特效 -->
     
        <script type="text/javascript">
            // 只在桌面版网页启用特效
            var windowWidth = $(window).width();
            if (windowWidth > 768) {
                document.write('<script type="text/javascript" src="/libs/others/star.js"><\/script>');
            }
        </script>
    

     
        <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
        <script src="/libs/others/TencentCaptcha.js"></script>
        <button id="TencentCaptcha" data-appid="xxxxxxxxxx" data-cbfn="callback" type="button" hidden></button>
    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    
    <script type="text/javascript" src="/libs/background/ribbon-dynamic.js" async="async"></script>
    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
